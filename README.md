# re•i•fy <sub>_verb, transitive_</sub> &nbsp; [![Build Status](https://travis-ci.org/benjamn/reify.svg?branch=master)](https://travis-ci.org/benjamn/reify)

**re•i•fied** <sub>past</sub> &nbsp; **re•i•fies** <sub>present</sub> &nbsp; **re•i•fy•ing** <sub>participle</sub> &nbsp; **re•i•fi•ca•tion** <sub>noun</sub> &nbsp; **re•i•fi•er** <sub>noun</sub>

  1. to make (something abstract) more concrete or real<br>
     _"these instincts are, in humans, reified as verbal constructs"_
  2. to regard or treat (an idea, concept, etc.) as if having material existence
  3. **to enable [ECMAScript 2015 modules](http://www.2ality.com/2014/09/es6-modules-final.html) in *any* version of [Node.js](https://nodejs.org)**

Usage
---

  1. Run `npm install --save reify` in your package or app directory. The
     `--save` is important because reification only applies to modules in
     packages that explicitly depend on the `reify` package.
  2. Call `require("reify")` before importing modules that contain `import`
     and `export` statements.

You can also easily `reify` the Node REPL:

```sh
% node
> require("reify/repl")
{}
> import { strictEqual } from "assert"
> strictEqual(2 + 2, 5)
AssertionError: 4 === 5
    at repl:1:1
    at REPLServer.defaultEval (repl.js:272:27)
  ...
```

How it works
---

Code generated by the `reify` compiler relies on a [simple runtime
API](lib/runtime.js) that can be explained through a series of
examples. While you do not have to write this API by hand, it is designed
to be easily human readable and writable, in part because that makes it
easier to explain.

I will explain the `Module.prototype.import` method first, then the
`Module.prototype.export` method after that.

Here we go:

```js
import a, { b, c as d } from "./module";
```
becomes
```js
// Local symbols are declared as ordinary variables.
let a, b, d;
module.import("./module", {
  // The keys of this object literal are the names of exported symbols.
  // The values are setter functions that take new values and update the
  // local variables.
  default: value => { a = value; },
  b: value => { b = value; },
  c: value => { d = value; },
});
```

All setter functions are called synchronously before `module.import`
returns, with whatever values are immediately available. However, when
there are import cycles, some setter functions may be called again, when
the exported values change. Calling these setter functions one or more
times is the key to implementing [*live
bindings*](http://www.2ality.com/2015/07/es6-module-exports.html), as
required by the ECMAScript 2015 specification.

While most setter functions only need to know the value of the exported
symbol, the name of the symbol is also provided as a second parameter
after the value. This parameter becomes important for `*` imports (and `*`
exports, but we'll get to that a bit later):

```js
import * as utils from "./utils";
```
becomes
```js
let utils = {};
module.import("./utils", {
  "*": (value, name) => {
    utils[name] = value;
  }
});
```

The setter function for `*` imports is called once for each symbol name
exported from the `"./utils"` module. If any individual value happens to
change after the call to `module.import`, the setter function will be
called again to update that particular value. This approach ensures that
the actual `exports` object is never exposed to the caller of
`module.import`.

Notice that this compilation strategy works equally well no matter where
the `import` statement appears:

```js
if (condition) {
  import { a as b } from "./c";
  console.log(b);
}
```
becomes
```js
if (condition) {
  let b;
  module.import("./c", {
    a: value => { b = value; }
  });
  console.log(b);
}
```

See [`WHY_NEST_IMPORTS.md`](WHY_NEST_IMPORTS.md) for a much more detailed
discussion of why nested `import` statements are worthwhile.

What about `export` statements? One option would be to transform them into
CommonJS code that updates the `exports` object, since interoperability
with Node and CommonJS is certainly a goal of this approach.

However, if `Module.prototype.import` takes a module identifier and a map
of *setter* functions, then it seems natural to have a
`Module.prototype.export` method that registers *getter* functions. Given
these getter functions, whenever `module.import(id, ...)` is called by a
parent module, the getters for the `id` module will run, updating its
`module.exports` object, so that the `module.import` method has access to
the latest exported values.

There are two styles of `module.export` calls, one for single exports and
another for multiple exports:

```js
export function func(x) { ... };
```
becomes
```js
function func (x) { ... };
module.export("func", () => func);
```

and

```js
export const a = "a", b = "b", ...;
```
becomes
```js
const a = "a", b = "b", ...;
module.export({
  a: () => a,
  b: () => b,
  ...
});
```

It's important that we register getter functions rather than storing
computed values, because the values of exported variables can change, and
we want other modules always to import the newest values.

But what about `export default` statements? It would be a mistake to defer
evaluation of the `default` expression until later, so wrapping it in a
getter function is not exactly what we want.

The important point to understand here is that `module.import` does not
assume a getter function has been registered by `module.export` for every
imported symbol. Instead, `parentModule.import` only cares about the
contents of `childModule.exports`. While the `childModule.export` method
helps keep `childModule.exports` up to date, that level of sophistication
isn't strictly necessary in every situation, and `default` exports are one
such situation:

```js
export default getDefault();
```
simply becomes
```js
exports.default = getDefault();
```

Now, if you are really committed to using `module.export` for everything
(and never touching `exports` directly), then of course you can get it to
work by evaluating the default expression and binding its value to a
getter function, like so:

```js
module.export("default", (def => () => def)(getDefault()));
```
or (if you prefer `Function.prototype.bind`)
```js
module.export("default", (def => def).bind(null, getDefault()));
```

What about `export ... from "./module"` statements? The key insight here
is that **`export` statements with a `from "..."` clause are really just
`import` statements that update the `exports` object instead of updating
local variables**:

```js
export { a, b as c } from "./module";
```
becomes
```js
module.import("./module", {
  a: value => { exports.a = value; },
  b: value => { exports.c = value; },
});
```

This strategy cleanly generalizes to `export * from "..."` statements:

```js
export * from "./module";
```
becomes
```js
module.import("./module", {
  "*": (value, name) => {
    exports[name] = value;
  }
});
```

While these examples have not covered every possible syntax for `import`
and `export` statements, I hope they provide the intuition necessary to
imagine how any statement could be compiled.

When I have some time, I hope to implement a [live-compiling text
editor](https://github.com/benjamn/reify/issues/15) to enable
experimentation.
