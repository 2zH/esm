# re•i•fy <sub>_verb, transitive_</sub> &nbsp; [![Build Status](https://travis-ci.org/benjamn/reify.svg?branch=master)](https://travis-ci.org/benjamn/reify)

**re•i•fied** <sub>past</sub> &nbsp; **re•i•fies** <sub>present</sub> &nbsp; **re•i•fy•ing** <sub>participle</sub> &nbsp; **re•i•fi•ca•tion** <sub>noun</sub> &nbsp; **re•i•fi•er** <sub>noun</sub>

  1. to make (something abstract) more concrete or real<br>
     _"these instincts are, in humans, reified as verbal constructs"_
  2. to regard or treat (an idea, concept, etc.) as if having material existence
  3. **to enable [ECMAScript 2015 modules](http://www.2ality.com/2014/09/es6-modules-final.html) in *any* version of [Node.js](https://nodejs.org)**

Usage
---

  1. Run `npm install --save reify` in your package or app directory. The
     `--save` is important because reification only applies to modules in
     packages that explicitly depend on the `reify` package.
  2. Call `require("reify")` before importing modules that contain `import`
     and `export` statements.

You can also easily `reify` the Node REPL:

```sh
% node
> require("reify/repl")
{}
> import { strictEqual } from "assert"
> strictEqual(2 + 2, 5)
AssertionError: 4 === 5
    at repl:1:1
    at REPLServer.defaultEval (repl.js:272:27)
  ...
```

How it works
---

Code generated by the `reify` compiler relies on a simple runtime API that can be explained through a series of examples.

```js
import a, { b, c as d } from "./module";
```
becomes
```js
// Local symbols are declared as ordinary variables.
let a, b, d;
module.import("./module", {
  // The keys of this object literal are the names of exported symbols.
  // The values are setter functions that take new values and update the
  // local variables.
  default: value => { a = value; },
  b: value => { b = value; },
  c: value => { d = value; },
});
```
All setter functions are called synchronously before `module.import` returns, with whatever values are immediately available. However, when there are import cycles, some setter functions may be called again, when the exported values change.

While most setter functions only need to know the value of the exported symbol, the name of the symbol is also provided as a second parameter after the value. This parameter becomes important for `*` imports and exports:

```js
import * as utils from "./utils";
```
becomes
```js
let utils = {};
module.import("./utils", {
  "*": (value, name) => {
    utils[name] = value;
  }
});
```
The setter function for `*` imports is called once for each name/value pair exported from the `"./utils"` module. If any individual value happens to change after the call to `module.import`, the setter function will be called again to update that particular value. This approach ensures that the actual `exports` object is never exposed to the caller of `module.import`.

Notice that this compilation strategy works equally well no matter where the `import` statement appears:

```js
if (condition) {
  import { a as b } from "./c";
  console.log(b);
}
```
becomes
```js
if (condition) {
  let b;
  module.import("./c", {
    a: value => { b = value; }
  });
  console.log(b);
}
```

What about `export` statements? One option would be to transform them into CommonJS code that updates the `exports` object, since interoperability with Node and CommonJS is certainly a goal of this approach.

However, if `Module.prototype.import` takes a module identifier and a map of *setter* functions, then it seems natural to have a `Module.prototype.export` method that registers *getter* functions. Given these getter functions, whenever `module.import(id, ...)` is called by a parent module, the getters for the `id` module run, updating its `module.exports` object, so that the `import` method has access to the latest exported values.

There are two styles of `module.export` calls, one for single exports and another for multiple exports:

```js
export function func(x) { ... };
```
becomes
```js
function func (x) { ... };
module.export("func", () => func);
```
and
```js
export const a = "a", b = "b", ...;
```
becomes
```js
const a = "a", b = "b", ...;
module.export({
  a: () => a,
  b: () => b,
  ...
});
```

But what about `export default` statements? It would be a mistake to defer evaluation of the default expression until later, so wrapping it in a getter function is not exactly what we want.

The important point to understand here is that `module.import` does not require a getter function to be registered by `module.export` for every imported symbol. No, `parentModule.import` only cares about the contents of `childModule.exports`. While `childModule.export` helps keep `childModule.exports` up to date, that level of sophistication isn't strictly necessary in every situation, and `default` exports are one such situation:

```js
export default getDefault();
```
simply becomes
```js
exports.default = getDefault();
```

Now, if you are really committed to using `module.export` for everything (and never touching `exports` directly), of course you can get it to work by evaluating the default expression and then binding it to a getter function, like so:

```js
module.export("default", (def => () => def)(getDefault()));
```
or (if you prefer `Function.prototype.bind`)
```js
module.export("default", (def => def).bind(null, getDefault()));
```

What about `export ... from "./module"` statements? The key insight here is that `export` statements with a `from "..."` clause are really `import` statements that update the `exports` object instead of updating local variables:

```js
export { a, b as c } from "./module";
```
becomes
```js
module.import("./module", {
  a: value => { exports.a = value; },
  b: value => { exports.c = value; },
});
```

This strategy cleanly generalizes to `export * from "..."` statements:

```js
export * from "./module";
```
becomes
```js
module.import("./module", {
  "*": (value, name) => {
    exports[name] = value;
  }
});
```

While these examples have not covered every possible syntax for `import` and `export` statements, they should provide the intuition necessary to imagine how any statement could be compiled. When I have some time, I hope to implement a [live-compiling text editor](https://github.com/benjamn/reify/issues/15) to enable experimentation.
