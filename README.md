# re•i•fy <sub>_verb, transitive_</sub> &nbsp; [![Build Status](https://travis-ci.org/benjamn/reify.svg?branch=master)](https://travis-ci.org/benjamn/reify)

**re•i•fied** <sub>past</sub> &nbsp; **re•i•fies** <sub>present</sub> &nbsp; **re•i•fy•ing** <sub>participle</sub> &nbsp; **re•i•fi•ca•tion** <sub>noun</sub> &nbsp; **re•i•fi•er** <sub>noun</sub>

  1. to make (something abstract) more concrete or real<br>
     _"these instincts are, in humans, reified as verbal constructs"_
  2. to regard or treat (an idea, concept, etc.) as if having material existence
  3. **to enable [ECMAScript 2015 modules](http://www.2ality.com/2014/09/es6-modules-final.html) in *any* version of [Node.js](https://nodejs.org)**

Usage
---

  1. Run `npm install --save reify` in your package or app directory. The
     `--save` is important because reification only applies to modules in
     packages that explicitly depend on the `reify` package.
  2. Call `require("reify")` before importing modules that contain `import`
     and `export` declarations.

You can also easily `reify` the Node REPL:

```sh
% node
> require("reify/repl")
{}
> import { strictEqual } from "assert"
> strictEqual(2 + 2, 5)
AssertionError: 4 === 5
    at repl:1:1
    at REPLServer.defaultEval (repl.js:272:27)
  ...
```

How it works
---

Code generated by the `reify` compiler relies on a [simple runtime
API](lib/runtime.js) that can be explained through a series of
examples. While you do not have to write this API by hand, it is designed
to be easily human readable and writable, in part because that makes it
easier to explain.

I will explain the `Module.prototype.import` method first, then the
`Module.prototype.export` method after that. Note that this `Module` is
the constructor of the CommonJS `module` object, and the `import` and
`export` methods are custom additions to `Module.prototype`.

Here we go:

```js
import a, { b, c as d } from "./module";
```
becomes
```js
// Local symbols are declared as ordinary variables.
let a, b, d;
module.import("./module", {
  // The keys of this object literal are the names of exported symbols.
  // The values are setter functions that take new values and update the
  // local variables.
  default: value => { a = value; },
  b: value => { b = value; },
  c: value => { d = value; },
});
```

All setter functions are called synchronously before `module.import`
returns, with whatever values are immediately available. However, when
there are import cycles, some setter functions may be called again, when
the exported values change. Calling these setter functions one or more
times is the key to implementing [*live
bindings*](http://www.2ality.com/2015/07/es6-module-exports.html), as
required by the ECMAScript 2015 specification.

While most setter functions only need to know the value of the exported
symbol, the name of the symbol is also provided as a second parameter
after the value. This parameter becomes important for `*` imports (and `*`
exports, but we'll get to that a bit later):

```js
import * as utils from "./utils";
```
becomes
```js
let utils = {};
module.import("./utils", {
  "*": (value, name) => {
    utils[name] = value;
  }
});
```

The setter function for `*` imports is called once for each symbol name
exported from the `"./utils"` module. If any individual value happens to
change after the call to `module.import`, the setter function will be
called again to update that particular value. This approach ensures that
the actual `exports` object is never exposed to the caller of
`module.import`.

Notice that this compilation strategy works equally well no matter where
the `import` declaration appears:

```js
if (condition) {
  import { a as b } from "./c";
  console.log(b);
}
```
becomes
```js
if (condition) {
  let b;
  module.import("./c", {
    a: value => { b = value; }
  });
  console.log(b);
}
```

See [`WHY_NEST_IMPORTS.md`](WHY_NEST_IMPORTS.md) for a much more detailed
discussion of why nested `import` declarations are worthwhile.

What about `export` declarations? One option would be to transform them into
CommonJS code that updates the `exports` object, since interoperability
with Node and CommonJS is certainly a goal of this approach.

However, if `Module.prototype.import` takes a module identifier and a map
of *setter* functions, then it seems natural to have a
`Module.prototype.export` method that registers *getter* functions. Given
these getter functions, whenever `module.import(id, ...)` is called by a
parent module, the getters for the `id` module will run, updating its
`module.exports` object, so that the `module.import` method has access to
the latest exported values.

There are three styles of `module.export` calls, one for multiple exports,
another for updating the value of a single export, and another for
bulk-updating the values of all exported variables.

The first style is to pass a single object literal of getter functions to
`module.export`. The `reify` compiler does this for you for every kind of
named `export` declaration:

```js
export const a = "a", b = "b", ...;
```

becomes

```js
const a = "a", b = "b", ...;
module.export({
  a: () => a,
  b: () => b,
  ...
});
```

The above code registers getter functions for the variables `a`, `b`, ...,
so that `module.import` can easily retrieve the latest values of those
variables at any time. It's important that we register getter functions
rather than storing computed values, so that other modules always can
import the newest values.

Suppose you change the value of an exported variable after the module has
finished loading. Then you need to let the module system know about the
update, and that's where the second style of `module.export` comes
in. This update is manual right now, but soon it will be provided
automatically by the `reify` compiler (see #27):

```js
export let value = 0;
export function increment(by) {
  return value += by;
};
```

should become

```js
module.export({
  value: () => value,
  increment: () => increment,
});
let value = 0;
function increment(by) {
  return module.export("value", value += by);
};
```

When called with a string as its first argument, `module.export` updates
the variable named by the string and returns the value of its second
argument.

The third and final way to call `module.export` is without any arguments.
This style is useful when you have no way of knowing which exported
variables may have been updated:

```js
export let value = 0;

function runCommand(command) {
  eval(command);
  module.export(); // Picks up new value.
}

runCommand("value = 1234");
```

But what about `export default` declarations? It would be a mistake to defer
evaluation of the `default` expression until later, so wrapping it in a
getter function is not exactly what we want.

The important point to understand here is that `module.import` does not
assume a getter function has been registered by `module.export` for every
imported symbol. Instead, `parentModule.import` only cares about the
contents of `childModule.exports`. While the `childModule.export` method
helps keep `childModule.exports` up to date, that level of sophistication
isn't strictly necessary in every situation, and `default` exports are one
such situation:

```js
export default getDefault();
```
simply becomes
```js
exports.default = getDefault();
```

What about `export ... from "./module"` declarations? The key insight here
is that **`export` declarations with a `from "..."` clause are really just
`import` declarations that update the `exports` object instead of updating
local variables**:

```js
export { a, b as c } from "./module";
```
becomes
```js
module.import("./module", {
  a: value => { exports.a = value; },
  b: value => { exports.c = value; },
});
```

This strategy cleanly generalizes to `export * from "..."` declarations:

```js
export * from "./module";
```
becomes
```js
module.import("./module", {
  "*": (value, name) => {
    exports[name] = value;
  }
});
```

While these examples have not covered every possible syntax for `import`
and `export` declarations, I hope they provide the intuition necessary to
imagine how any declaration could be compiled.

When I have some time, I hope to implement a [live-compiling text
editor](https://github.com/benjamn/reify/issues/15) to enable
experimentation.
